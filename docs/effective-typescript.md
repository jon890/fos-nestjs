# 이펙티브 타입스크립트

## 아이템 1 : 타입스크립트와 자바스크릡트의 관계 이해하기

- 타입스크립트는 자바스크립트의 상위 집합이다.
- 타입스크립트는 자바스크립트의 상위 집합이므로, `.js` 파일에 있는 코드는 이미 타입스크립트라고 할 수 있음
- 따라서 `main.js` 파일명을 `main.ts`로 바꿔도 달라지는 것은 없음
  - 이러한 특성이 기존 코드를 유지하면서 마이그레이션하는데 엄청난 이점이 됨
- 타입스크립트 프로그램이지만, 자바스크립트 프로그램이 아닐 수 있음
  - 타입스크립트가 타입을 명시하는 추가적인 문법을 가지기 때문
- 타입 시스템의 목표는 런타임에 오류를 발생시킬 코드를 미리 찾아내는 것
- 모든 자바스크립트는 타입스크립트이지만, 일부 자바스크립트(그리고 타입스크립트) 만이 타입 체크를 통과함

## 아이템 2 : 타입스크립트 설정 이해하기

- 타입스크립트 설정은 커맨드라인보다는, `tsconfig.json`을 사용하자
- any 타입을 매개변수에 사용하면 타입 체커는 무력해진다.
- any는 유용하지만 매우 주의해서 사용해야 함
- 엄격한 체크를 하고 싶다먀ㅕㄴ, `strict` 설정을 고려하자

- `noImplicitAny`
  - 암시적 any : any를 코드에 넣지 않았지만, any 타입으로 간주될 때
  - 타입스크립트는 타입 정보를 가질 때 가장 효과적이기 때문에, 되도록이면 설정해야 함
- `strictNullChecks`
  - `null`과 `undefined`가 모든 타입에서 허용되는지 확인하는 설정

  ```ts
  // strict null checks : false
  const x: number = null; // 정상, null은 유효한 값

  // strict null checks : true
  const x: number = null;
  // `null` 형식은 `number` 형식에 할당할 수 없습니다.
  ```

## 아이템 3 : 코드 생성과 타입이 관계없음을 이해하기

- 큰 그림으로 보면, 타입스크립트 컴파일러는 두 가지 역할을 수행
  1. 최신 타입스크립트/자바스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일한다.
  2. 코드의 타입 오류를 체크한다.

- 위 2가지는 완벽히 독립적임
- 타입스크립트가 자바스크립트로 변환될 때 코드 내의 타입에는 영향을 주지 않음
- 또한 자바스크립트 실행 시점에도 타입은 영향을 주지 않음

- 타입 오류가 있는 코드도 컴파일이 가능
  - 타입스크립트 오류는 C나 자바 같은 언어들의 경고와 비슷
  - 문제가 될 만한 부분을 알려주지만 빌드를 멈추진 않음
  - 오류가 있을 때, 컴파일하지 않으려면 `tsconfig.json`에 `noEmitOnError`를 설정
- 런타임에는 타입 체크가 불가능
  - `instanceof` 체크는 런타임에 일어나지만, 타입은 런타임 시점에 아무런 역할을 할 수 없음
  - 타입스크립트에서 자바스크립트로 컴파일되는 과정에서 모든 인터페이스, 타입, 타입 구문은 그냥 제거되어 버림
- 런타임 타입은 선언된 타입과 다를 수 있음
- 타입스크립트 타입으로는 함수를 오버로드 할 수 없음
- 타입스크립트 타입은 런타임 성능에 영향을 주지 않음
- 런타임에 타입을 사용하려면?
  - 클래스 같이 타입스크립트 타입과 런타임 값을 둘다 제공하는 방법
  - 태그된 유니온과 속셍 체크 방법을 사용
    - `type` 속성을 두어서, 각 타입 속성 값에 따라 구분하는 방법

## 아이템 4 : 구조적 타이핑에 익숙해지기

- 자바스크립트는 본질적으로 덕 타이핑 기반
  - 객체가 어떤 타입에 부합하는 변수와 메서드를 가질 경우 객체를 해당 타입에 속하는 것으로 간주하는 방식
- 함수를 작성할 때, 호출에 사용되는 매개변수의 속성들이 매개변수의 타입에 선언된 속성만을 가질거라 생각하기 쉽다
  - 이러한 타입은 봉인된 또는 정확한 타입이라고 불리며, 타입스크립트 타입 시스템에서는 표현할 수 없다
- 타입스크립트의 타입은 열려있음
- 큻래스 역시 구조적 타이핑 규칙을 따름
  - 클래스의 인스턴스가 예상과 다를 수 있음
- 테스트 작성할 때 유리
  - 구조적 타이핑 덕분에 DB 인터페이스를 구현하는지 명확히 선언할 필요가 없음
- 라이브러리 간의 의존성을 완벽히 분리할 수 있음 => 아이템 51에서 자세히 다룸

## 아이템 5 : any 타입 지양하기

- 타입스크립트의 타입 시스템은 점진적이고, 선택적임
  - 코드에 조금씩 타입을 추가할 수 있음 => 점진적
  - 언제든지 타입 체커를 해제할 수 있음 => 선택적
- 이 기능들의 핵심은 any 타입임
  - 타입 선언을 추가하는 데에 시간을 쏟지 않고 싶어, any 타입이나, 타입 단언문(`as any`)을 사용하고 싶기도 할 것임

- 부득이하게 any를 사용하더라도 위험성은 알아야 함
  - any 타입에는 안전성이 없음
  - any는 함수 시그니처를 무시해버림
  - any 타입에는 언어 서비스가 적용되지 않음
    - 언어 서비스는 자동완성 기능과 적절한 도움말을 제공
  - any 타입은 코드 리팩터링 때 버그를 감춤
  - any는 타입 설계를 감춰버림
    - 애플리케이션 상태 같은 객체를 정의하려면 꽤 복잡함
    - 물론 이 때도 any를 사용하면 안 됨
    - any 타입을 사용하면 타입 설계가 불분명해지고, 설계가 잘 되었는지, 설계가 어떻게 되어있는지 전혀 알 수 없음
  - any는 타입시스템의 신뢰도를 떯어뜨림
    - 런타임에 타입 오류를 발견하게 된다면 타입 체커를 신뢰할 수 없게 됨
    - any 타입을 쓰지 않으면 런타임에 발견될 오류를 미리 잡을 수 있고, 신뢰도를 높일 수 있음
